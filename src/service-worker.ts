/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import { Storage } from '@ionic/storage';
import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { StaleWhileRevalidate } from "workbox-strategies";
import { CACHE_USER_LOGIN_ROLE_NAME } from "./utils/StorageUtil";



declare const self: ServiceWorkerGlobalScope;

let CACHE_NAME = 'scholar-present-cache-v2';
let urlsToCache:any = [];

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }: { request: Request; url: URL }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== "navigate") {
            return false;
        }

        // If this is a URL that starts with /_, skip.
        if (url.pathname.startsWith("/_")) {
            return false;
        }

        // If this looks like a URL for a resource, because it contains
        // a file extension, skip.
        if (url.pathname.match(fileExtensionRegexp)) {
            return false;
        }

        // Return true to signal that we want to use the handler.
        return true;
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
    // Add in any other file extensions or routing criteria as needed.
    ({ url }) => url.origin === self.location.origin && url.pathname.endsWith(".png"),
    // Customize this strategy as needed, e.g., by changing to CacheFirst.
    new StaleWhileRevalidate({
        cacheName: "images",
        plugins: [
            // Ensure that once this runtime cache reaches a maximum size the
            // least-recently used images are removed.
            new ExpirationPlugin({ maxEntries: 50 }),
        ],
    })
);

self.addEventListener('install', function(event) {
    // Perform install steps
    try{
        // event.waitUntil(
        //     caches.open(CACHE_NAME)
        //       .then(function(cache) {
        //         console.log('Opened cache');
        //         return cache.addAll(urlsToCache);
        //       })
        //   );
    }catch(ex){
        console.error("install error ", ex)
    }
    
  });

  // https://developers.google.com/web/fundamentals/primers/service-workers
  self.addEventListener('fetch', function(event) {
    try{
        // event.respondWith(
        // caches.match(event.request)
        //     .then(function(response) {
        //     // Cache hit - return response
        //     if (response) {
        //         return response;
        //     }
        //     return fetch(event.request);
        //     }
        // )
        // );
        event.respondWith(fetch(event.request));
    }catch(ex){
        console.error("fetch error ", ex)
    }
  });

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
    console.warn("[Service Worker] Message from main page", event);
    if (event.data && event.data.type === "SKIP_WAITING") {
        self.skipWaiting();
    }
});

// @ts-ignore
function postMsg(data) {
    self.clients.matchAll().then(function (clients) {
        console.warn("[Service Worker] clients ",  clients );
        (clients || []).forEach(function (client) {
            console.warn("[Service Worker] postMessage data ",  data );
            client.postMessage(data);
        });
    });
}

self.addEventListener("push", (event:any) => {
    // @ts-ignore
    console.log("[Service Worker] Push Received.: ", event);

    console.log(`[Service Worker] Push Received.: "${event.data.text()}"`);

    // @ts-ignore
    if (!(self.Notification && self.Notification.permission === "granted")) {
        return;
    }

    var data:any = {conversationId:"", messageId:""};

    if (event.data) {
        data = event.data.json();
    }

    // @ts-ignore
    var title = data.title || "Web Push Notification";
    // @ts-ignore
    var message = data.body || "New Push Notification Received";
    var icon = "/assets/icon/favicon.ico";
    var badge = "/assets/icon/favicon.ico";
    if( data?.data?.signature){
        message =  data?.data?.signature + " - " + message;
    }
    var options = {
        body: message,
        icon: icon,
        badge: badge,
        data:data?.data
    };
    postMsg({
        type: "MSG_RECEIVED",
        // @ts-ignore
        messageId: data.messageId,
        conversationId: data.conversationId,
        // @ts-ignore
        body: data.body,
        data: data.data

    });

    const store = new Storage();
    store.create().then((value:any)=>{
        console.log("data ", data);
        console.log("cache new message reference messageId ", data?.messageId);
        store.set("MESSAGE_"+data?.messageId, data?.messageId);
    });

    event.waitUntil(self.registration.showNotification(title, options));
});

self.addEventListener("notificationclick", async(event) => {
    event.notification.close();
    console.log("[Service Worker] Notification click: ", event);
    const store = new Storage();
    await store.create();
    let userLogonRoleName = await store.get(CACHE_USER_LOGIN_ROLE_NAME);
    let conversationId = event.notification.data?.conversationId;
    let launchURL = "app.scholarpresent.com";
    if(userLogonRoleName !== "Student" && userLogonRoleName !== "Parent"){
        launchURL += "/messaging/"+conversationId;
    }else{
        launchURL += "/lmessaging/"+conversationId;
    } 

    console.log("[Service Worker] Notification click: ", launchURL);
    // Now wait for the promise to keep the permission alive.
    var promise = new Promise(function(resolve) {
        setTimeout(resolve, 3000);
    }).then(function() {
        self.clients.matchAll({
            type: "window",
        }).then((clientsArr: any) => {
            console.log("clientsArr ", clientsArr);
            // If a Window tab matching the targeted URL already exists, focus that;
            const hadWindowToFocus = clientsArr.some((windowClient:any) => windowClient.url === launchURL ? (windowClient.focus(), true) : false);
            // Otherwise, open a new tab to the applicable URL and focus it.
            // for (var i = 0; i < clientsArr.length; i++) {
            //     var client = clientsArr[i];
            //     if (client.url.indexOf("app.scholarpresent.com" ) > 0 && 'focus' in client) {
            //         console.log("focus on  client.url ", client.url );
            //         client.focus();
            //         //return self.clients.openWindow(launchURL).then((client:any)=>client.navigate(launchURL));
            //     }
            //   }
            if (!hadWindowToFocus)
                return self.clients.openWindow(launchURL).then((windowClient) => (windowClient ? windowClient.focus() : null));
                
            console.log("hadWindowToFocus ", hadWindowToFocus);

            // if (!hadWindowToFocus){
            // } self.clients.openWindow(launchURL).then((windowClient:any) => windowClient ? windowClient.focus() : null);
            // console.log("Open new Window");
            
        })
        })
        
        event.waitUntil(
                    // @ts-ignore
            promise);
    
    
});


